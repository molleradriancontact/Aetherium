/**
 * @file Firestore Security Rules
 * @core_philosophy This ruleset enforces a mixed security model. User profiles
 *  are readable by anyone but writable only by the owning user. Projects
 *  are publicly listable but require authentication for creation and ownership for modification.
 *  Invitations are scoped to individual users. Client records are scoped to designers (users).
 * @data_structure
 *  /users/{userId} - Stores user profile information.
 *  /projects/{projectId} - Stores project data.
 *  /users/{userId}/invitations/{invitationId} - Stores invitations for project collaboration.
 *  /users/{userId}/clients/{clientId} - Stores designer's client information.
 * @key_security_decisions
 *  - Users can only modify their own profiles.
 *  - Projects are publicly listable, but creation, updates, and deletion are restricted to the owner.
 *  - Invitations are private to the invited user.
 *  - Listing of user documents is disallowed, preventing enumeration.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read their own profile data, and create their own profile.
     * @path /users/{userId}
     * @allow (get) Signed-in user can read any user profile.
     * @allow (create) Signed-in user can create their own profile.
     * @allow (update) Signed-in user can update their own profile.
     * @allow (delete) No one can delete a user profile via rules.
     * @deny (get) An unauthenticated user cannot read any user profiles.
     * @deny (create) A user cannot create a profile for another user.
     * @deny (update) A user cannot modify another user's profile.
     * @deny (delete) A user cannot delete another user's profile.
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false;

      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.id == userId;
      allow delete: if false;
    }

    /**
     * @description Allows anyone to list projects, but requires authentication and ownership for modifications.
     * @path /projects/{projectId}
     * @allow (get) Anyone can read a project.
     * @allow (list) Anyone can list all projects.
     * @allow (create) Signed-in user can create a project with their userId as ownerId.
     * @allow (update) Signed-in user who owns the project can update it.
     * @allow (delete) Signed-in user who owns the project can delete it.
     * @deny (create) A user cannot create a project for another user.
     * @deny (update) A user cannot modify a project they don't own.
     * @deny (delete) A user cannot delete a project they don't own.
     * @principle Enforces public read access with owner-only writes for projects.
     */
    match /projects/{projectId} {
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows a user to only read their own invitations.
     * @path /users/{userId}/invitations/{invitationId}
     * @allow (get) Signed-in user can read their own invitations.
     * @allow (create) Signed-in user can create an invitation for themself (plausibly via a trusted function).
     * @allow (update) Signed-in user can update an invitation for themself.
     * @allow (delete) Signed-in user can delete an invitation for themself.
     * @deny (get) An unauthenticated user cannot read invitations.
     * @deny (get) A user cannot read another user's invitations.
     * @deny (create) A user cannot create an invitation for another user.
     * @deny (update) A user cannot update another user's invitations.
     * @deny (delete) A user cannot delete another user's invitations.
     * @principle Enforces user-ownership for invitations.
     */
    match /users/{userId}/invitations/{invitationId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

      /**
       * @description Allows a designer (user) to manage their own client records.
       * @path /users/{designerId}/clients/{clientId}
       * @allow (get) Signed-in designer can read their client records.
       * @allow (list) Signed-in designer can list their client records.
       * @allow (create) Signed-in designer can create a client record.
       * @allow (update) Signed-in designer can update their client record.
       * @allow (delete) Signed-in designer can delete their client record.
       * @deny (get) An unauthenticated user cannot read any client records.
       * @deny (get) A designer cannot read another designer's client records.
       * @deny (create) A designer cannot create a client record under another designer's ID.
       * @deny (update) A designer cannot modify a client record under another designer's ID.
       * @deny (delete) A designer cannot delete a client record under another designer's ID.
       * @principle Enforces designer-ownership for client records.
       */
    match /users/{designerId}/clients/{clientId} {
        allow get: if isSignedIn() && isOwner(designerId);
        allow list: if isSignedIn() && isOwner(designerId);

        allow create: if isSignedIn() && isOwner(designerId) && request.resource.data.designerId == designerId;
        allow update: if isSignedIn() && isExistingOwner(designerId) && resource.data.designerId == designerId;
        allow delete: if isSignedIn() && isExistingOwner(designerId) && resource.data.designerId == designerId;
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}